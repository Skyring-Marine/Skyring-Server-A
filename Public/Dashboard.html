<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="icon" href="https://getbootstrap.com/docs/4.0/assets/img/favicons/favicon.ico">
  <title>Skyring Marine</title>
  <link rel="canonical" href="https://getbootstrap.com/docs/4.0/examples/dashboard/">
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://getbootstrap.com/docs/4.0/examples/dashboard/dashboard.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.164.1/examples/js/controls/OrbitControls.js"></script>

  <style>
    #windRose { max-height: 160px; }
    #myChart { max-height: 300px; }

    .navbar { background-color: #004e7c !important; }
    .form-control-dark {
      background-color: rgba(173, 216, 230, 0.3);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.5);
    }
    .form-control-dark::placeholder { color: #eee; }
    .sidebar { background-color: #e0f7fa !important; }

    #buoyCanvas { width: 100% !important; height: 100% !important; display: block; }

    /* Popups container */
    #popups-container {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 10;
    }
    .popup {
      position: absolute; background: rgba(255,255,255,0.85);
      border-radius: 12px; padding: 12px 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.25);
      font-size: 14px; color: #001D3D; max-width: 140px; pointer-events: auto;
      user-select: none; font-weight: bold;
    }

    #chart1, #chart2, #chart3 {
      background-color: rgba(30, 30, 30, 0.8);
      border-radius: 8px;
      padding: 10px;
    }

    /* HUD */
    #buoyContainer { position: relative; }
    #dashboard.hud {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 12px; z-index: 20; pointer-events: none;
    }
    #dashboard .card {
      pointer-events: auto; display: flex; flex-direction: column; align-items: center;
      width: 96px; padding: 8px 12px; border-radius: 10px;
      color: #fff; text-shadow: 0 1px 1px rgba(0,0,0,.25);
      background: rgba(255,255,255,0.10); backdrop-filter: blur(6px) saturate(120%);
      -webkit-backdrop-filter: blur(6px) saturate(120%); border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 4px 14px rgba(0,0,0,.18);
    }
    #dashboard .icon { font-size: 16px; margin-bottom: 4px; opacity: .95; }
    #dashboard .num  { font-weight: 800; font-size: 16px; line-height: 1.1; }
    #dashboard .label{ font-size: 11px; opacity: .9; }
    #dashboard .blue  { background: rgba(33,150,243,0.35); }
    #dashboard .red   { background: rgba(244, 67, 54,0.35); }
    #dashboard .green { background: rgba( 76,175, 80,0.35); }
    #dashboard .cyan  { background: rgba(  0,188,212,0.35); }
  </style>
</head>
<body>
<nav class="navbar navbar-dark sticky-top flex-md-nowrap p-0">
  <a class="navbar-brand col-sm-3 col-md-2 mr-0" href="#">Skyring Marine</a>
 <!--  <input class="form-control form-control-dark w-100" type="text" placeholder="Search">-->
  <ul class="navbar-nav px-3">
    <li class="nav-item text-nowrap">
      <a class="nav-link" href="#">Sign out</a>
    </li>
  </ul>
</nav>

<div class="container-fluid">
  <div class="row">
    <nav class="col-md-2 d-none d-md-block sidebar">
      <div class="sidebar-sticky">
        <ul class="nav flex-column">
          <!--<li class="nav-item"><a class="nav-link active" href="#"></a></li>
           <li class="nav-item"><a class="nav-link" href="#">Registros</a></li>
          <li class="nav-item"><a class="nav-link" href="#">Usuarios</a></li>
          <li class="nav-item"><a class="nav-link" href="#">Series de Tiempo</a></li>
          <li class="nav-item"><a class="nav-link" href="#">Alarmas</a></li> -->
        </ul>
        <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted">
         <!--  <span>Reportes</span> -->
        </h6>
        <ul class="nav flex-column mb-2">
         <!--  <li class="nav-item"><a class="nav-link" href="#">√öltimos 3 d√≠as</a></li>
          <li class="nav-item"><a class="nav-link" href="#">Semanal</a></li>
          <li class="nav-item"><a class="nav-link" href="#">Mensual</a></li>-->
        </ul>
        <div class="text-center mt-5 mb-3">
          <img src="images/logo2.png" alt="Logo PMEJ" style="max-width: 80%; height: auto;">
        </div>
      </div>
    </nav>

    <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">
      <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pb-2 mb-3 border-bottom">
        <h1 class="h2">Dashboard</h1>
      </div>

      <div class="d-flex" style="width: 100%; height: calc(100vh - 150px);">
        <!-- Izquierda: Buoy3D -->
        <div id="buoyContainer" style="width: 50%; padding-right: 20px; height: 100%;">
          <div id="dashboard" class="hud">
           <div class="card blue">
  <div class="icon">üåä</div>
  <div class="num" id="hsValue">--</div>
  <div class="label">Hs (m)</div>
</div>

<div class="card red">
  <div class="icon">‚è±Ô∏è</div>
  <div class="num" id="tpValue">--</div>
  <div class="label">Tp (s)</div>
</div>

<div class="card green">
  <div class="icon">üß≠</div>
  <div class="num" id="dirValue">--</div>
  <div class="label">Dir (¬∞)</div>
</div>

<div class="card cyan">
  <div class="icon">üìè</div>
  <div class="num" id="depValue">--</div>
  <div class="label">Dep (m)</div>
</div>
          </div>
        </div>

<!-- Derecha: Charts -->
<div class="d-flex flex-column" style="width: 50%; height: 100%; gap: 0;">
  <canvas id="chart1" style="height: 33%; margin-bottom: 0;"></canvas>
  <canvas id="chart2" style="height: 33%; margin-bottom: 0;"></canvas>
  <canvas id="chart3" style="height: 34%; margin-bottom: 0;"></canvas>

  <!-- Slider (parte en m√°ximo) -->
  <input 
    type="range" 
    id="chartSlider" 
    min="1" max="100" value="100"
    style="margin-top: 10px; width: 100%;">

  <!-- Botones de zoom -->
  <div class="d-flex justify-content-center" style="margin-top: 10px; gap: 10px;">
    <button id="zoomIn" class="btn btn-sm btn-secondary">
      <i class="bi bi-zoom-in"></i> <!-- Lupa + -->
    </button>
    <button id="zoomOut" class="btn btn-sm btn-secondary">
      <i class="bi bi-zoom-out"></i> <!-- Lupa - -->
    </button>
  </div>
</div>





      </div>

      <h2 class="mt-4">√öltimos Registros</h2>
      <div class="table-responsive">
        <table class="table table-striped table-sm" id="tabla-registros">
          <thead>
            <tr>
              <th>N¬∞</th>
              <th>Fecha</th>
              <th>Hora</th>
              <th>Hs (m)</th>
              <th>Tp (s)</th>
              <th>Dir (¬∞)</th>
              <th>Dep (m)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div id="pagination-controls" style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
        <button id="prevPage" disabled>Anterior</button>
        <span id="pageInfo">P√°gina 1</span>
        <button id="nextPage" disabled>Siguiente</button>
      </div>
    </main>
  </div>
</div>

<script>
  // =========================
  //  CHARTS
  // =========================


  let freezeBoya = false;






let chart1, chart2, chart3;
let highlightIndex = 0;           // √≠ndice global del punto resaltado (en los datos completos)
let viewStart = 0, viewEnd = 0;   // ventana visible [start, end] en datos completos
let zoomLevel = 0;                // 0 = vista completa, 1..N = zoom creciente

// Copias de los datos completos
let fullLabels = [];
let fullHs = [], fullTp = [], fullDepth = [];


function initCharts() {
  chart1 = new Chart(document.getElementById('chart1'), {
    type: 'line',
    data: {
      labels: Array(77).fill(0).map((_,i)=>"P"+(i+1)),
      datasets: [{
        label: "HS (M)",
        data: Array(77).fill(0),
        borderColor: "#007bff",
        backgroundColor: "rgba(0,123,255,0.2)",
        tension: 0.4, fill: true
      }]
    },
    options: baseChartOptions('ALTURA DE OLA SIGNIFICATIVA HS (M)')
  });

  chart2 = new Chart(document.getElementById('chart2'), {
    type: 'line',
    data: {
      labels: chart1.data.labels,
      datasets: [{
        label: "PERIODO PEAK (S)",
        data: Array(77).fill(0),
        borderColor: "#28a745",
        backgroundColor: "rgba(40,167,69,0.2)",
        tension: 0.4, fill: true
      }]
    },
    options: baseChartOptions('PERIODO PEAK (S)')
  });

  chart3 = new Chart(document.getElementById('chart3'), {
    type: 'line',
    data: {
      labels: chart1.data.labels,
      datasets: [{
        label: "ALTURA DE MAREA (M)",
        data: Array(77).fill(0),
        borderColor: "#dc3545",
        backgroundColor: "rgba(220,53,69,0.2)",
        tension: 0.4, fill: true
      }]
    },
    options: baseChartOptions('ALTURA DE MAREA (M NRS)')
  });

  // Guardar copias completas
  fullLabels = chart1.data.labels.slice();
  fullHs     = chart1.data.datasets[0].data.slice();
  fullTp     = chart2.data.datasets[0].data.slice();
  fullDepth  = chart3.data.datasets[0].data.slice();

  // Slider por √≠ndice (0..N-1), arrancar en el √∫ltimo
  const slider = document.getElementById("chartSlider");
  const total = fullLabels.length;
  slider.min = 0; slider.max = total - 1; slider.step = 1; slider.value = slider.max;
  highlightIndex = Number(slider.value);

  slider.addEventListener("input", () => {
    highlightIndex = Number(slider.value);
    applyZoom(); // redibuja respetando zoom actual
  });

  // Ventana inicial = vista completa
  viewStart = 0; viewEnd = total - 1;
  applyZoom();

  // Botones de zoom (a√±ade estos IDs en tu HTML)
  const btnIn  = document.getElementById('zoomIn');
  const btnOut = document.getElementById('zoomOut');

  if (btnIn) {
    btnIn.addEventListener('click', () => {
      zoomLevel = Math.min(10, zoomLevel + 1); // tope 10 niveles
      applyZoom();
    });
  }
  if (btnOut) {
    btnOut.addEventListener('click', () => {
      zoomLevel = Math.max(0, zoomLevel - 1);
      applyZoom();
    });
  }
}


function baseChartOptions(title) {
  return {
    responsive: true,
    plugins: {
      legend: { display: false },
      title: { display: true, text: title, font: { size: 16, weight: 'bold' }, color: '#fff' }
    },
    elements: {
      point: {
        radius: (ctx) => ((ctx.dataIndex + viewStart) === highlightIndex ? 7 : 3),
        backgroundColor: (ctx) => ((ctx.dataIndex + viewStart) === highlightIndex ? 'yellow' : ctx.dataset.borderColor),
        borderColor: (ctx) => ctx.dataset.borderColor,
        borderWidth: (ctx) => ((ctx.dataIndex + viewStart) === highlightIndex ? 2 : 1)
      }
    },
    scales: {
      y: { beginAtZero: true, min: 0, ticks: { color: '#eee' }, grid: { color: 'rgba(255,255,255,0.1)' } },
      x: { ticks: { color: '#eee' }, grid: { color: 'rgba(255,255,255,0.1)' } }
    }
  };
}



function applyZoom() {
  const total = fullLabels.length;

  // Asegurar highlightIndex dentro de rango por si cambi√≥ el total
  if (highlightIndex > total - 1) highlightIndex = total - 1;
  if (highlightIndex < 0) highlightIndex = 0;

  if (zoomLevel === 0) {
    viewStart = 0; viewEnd = total - 1;
  } else {
    const span = Math.max(5, Math.floor(total / (2 ** zoomLevel))); // ancho de ventana
    let half  = Math.floor(span / 2);

    let s = highlightIndex - half;
    let e = s + span - 1;

    if (s < 0) { s = 0; e = Math.min(total - 1, s + span - 1); }
    if (e > total - 1) { e = total - 1; s = Math.max(0, e - span + 1); }

    viewStart = s; viewEnd = e;
  }

  // Aplicar recorte a los 3 charts
  const L = fullLabels.slice(viewStart, viewEnd + 1);
  chart1.data.labels = L;
  chart2.data.labels = L;
  chart3.data.labels = L;

  chart1.data.datasets[0].data = fullHs.slice(viewStart, viewEnd + 1);
  chart2.data.datasets[0].data = fullTp.slice(viewStart, viewEnd + 1);
  chart3.data.datasets[0].data = fullDepth.slice(viewStart, viewEnd + 1);

  chart1.update(); chart2.update(); chart3.update();
}




function updateCharts() {
  chart1.update();
  chart2.update();
  chart3.update();
}

// Si cambias los datos din√°micamente, mant√©n el slider sincronizado:
function actualizarGraficos(labels, dataHs, dataTp, dataDepth) {
  // Actualizar copias completas
  fullLabels = labels.slice();
  fullHs = dataHs.slice();
  fullTp = dataTp.slice();
  fullDepth = dataDepth.slice();

  // Reconfigurar slider y highlight
  const slider = document.getElementById("chartSlider");
  slider.min = 0;
  slider.max = fullLabels.length - 1;
  slider.step = 1;
  slider.value = slider.max;           // ir al √∫ltimo al recargar datos
  highlightIndex = Number(slider.value);

  // Reiniciar ventana con zoom actual alrededor del nuevo highlight
  applyZoom();
}



  // =========================
  //  THREE.JS - ESCENA
  // =========================
 let isMouseDown = false, mouseX = 0, mouseY = 0;
let targetRotationX = Math.PI / 3;  // 45¬∞ horizontal
let targetRotationY = Math.PI / 6;  // 30¬∞ vertical
  const container = document.getElementById('buoyContainer');
  if (getComputedStyle(container).position === 'static') container.style.position = 'relative';

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x001D3D);

  const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(6, 6, 6);  // M√°s alto y oblicuo
camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  const ambientLight = new THREE.AmbientLight(0x404040, 1);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0x70aaff, 0.5);
  directionalLight.position.set(0, 1, 1);
  scene.add(directionalLight);

  // Fondo y agua
  const oceanFloor = new THREE.Mesh(
    new THREE.PlaneGeometry(7, 7, 4, 4),
    new THREE.MeshPhongMaterial({ color: 0x003050, side: THREE.DoubleSide, shininess: 10 })
  );
  oceanFloor.rotation.x = -Math.PI / 2;
  oceanFloor.position.y = -3;
  scene.add(oceanFloor);


const dashedLinesGroup = new THREE.Group();

if (freezeBoya) {
scene.add(dashedLinesGroup);
}

function createDashedLineAtY(yPosition) {
  const directions = [
    new THREE.Vector3(0, 0, 1),   // Norte (+Z)
    new THREE.Vector3(0, 0, -1),  // Sur (‚àíZ)
    new THREE.Vector3(1, 0, 0),   // Este (+X)
    new THREE.Vector3(-1, 0, 0)   // Oeste (‚àíX)
  ];

  const group = new THREE.Group(); // Agrupa las 4 l√≠neas

  directions.forEach(dir => {
    const start = new THREE.Vector3(0, yPosition, 0);
    const end = start.clone().add(dir.multiplyScalar(3)); // 3 unidades hacia la direcci√≥n

    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    const material = new THREE.LineDashedMaterial({
      color: 0xffffff,
      linewidth: 1,
      scale: 1,
      dashSize: 0.2,
      gapSize: 0.1
    });

    const line = new THREE.Line(geometry, material);
    line.computeLineDistances(); // Importante para l√≠neas punteadas
    group.add(line);
  });

  return group;
}






  const waterGeometry = new THREE.PlaneGeometry(6, 6, 20, 20);
  const waterMaterial = new THREE.MeshPhongMaterial({
    color: 0x1E90FF, transparent: true, opacity: 0.6, side: THREE.DoubleSide, shininess: 100, flatShading: true
  });
  const water = new THREE.Mesh(waterGeometry, waterMaterial);
  water.rotation.x = -Math.PI / 2;
  water.position.y = 3;
  scene.add(water);

function createCardinalSprite(letter, positionVec3) {
  const size = 256;
  const cvs = document.createElement('canvas');
  const ctx = cvs.getContext('2d');
  cvs.width = cvs.height = size;
  ctx.clearRect(0, 0, size, size);

  // üîÅ Inversi√≥n de Z para alinear con sistema mar√≠timo
  const angleRad = Math.atan2(positionVec3.x, -positionVec3.z);
  let angleDeg = angleRad * 180 / Math.PI;
  angleDeg = (angleDeg + 360) % 360;

  // Texto y grados
  ctx.font = 'bold 180px Helvetica, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(0,0,0,0.4)';
  ctx.shadowBlur = 8;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 2;
  ctx.fillStyle = '#ffffff';
  ctx.fillText(letter, size / 2, size / 2);

  ctx.font = 'bold 36px Helvetica, Arial, sans-serif';
  ctx.fillStyle = '#aaffff';
  ctx.fillText(`${angleDeg.toFixed(1)}¬∞`, size / 2, size / 2 + 100);

  const tex = new THREE.CanvasTexture(cvs);
  tex.needsUpdate = true;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
  const sprite = new THREE.Sprite(mat);

  const worldScale = 1.2;
  sprite.scale.set(worldScale, worldScale, 1);
  sprite.position.copy(positionVec3);
  scene.add(sprite);

  console.log(`üß≠ Sprite "${letter}" creado en direcci√≥n ${angleDeg.toFixed(1)}¬∞`);
}
createCardinalSprite('N', new THREE.Vector3(0, 0, -3.4)); // Z‚àí ahora es Norte
createCardinalSprite('E', new THREE.Vector3(3.4, 0, 0));  // X+ es Este
createCardinalSprite('S', new THREE.Vector3(0, 0, 3.4));  // Z+ es Sur
createCardinalSprite('O', new THREE.Vector3(-3.4, 0, 0)); // X‚àí es Oeste

  // Burbujas
  const bubbleCount = 50;
  const bubblesGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(bubbleCount * 3);
  for (let i = 0; i < bubbleCount; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 6;
    positions[i * 3 + 1] = (Math.random() - 0.5) * 6;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 6;
  }
  bubblesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const bubblesMaterial = new THREE.PointsMaterial({ color: 0xA0C8FF, size: 0.05, transparent: true, opacity: 0.3, depthWrite: false });
  const bubbles = new THREE.Points(bubblesGeometry, bubblesMaterial);
  scene.add(bubbles);

  // Boya
  const buoyGroup = new THREE.Group();
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshPhongMaterial({ color: 0xff4444 }));
  sphere.position.y = 0.5; buoyGroup.add(sphere);
  const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 5.7, 16), new THREE.MeshPhongMaterial({ color: 0xffff00 }));
  mast.position.y = 2.85; buoyGroup.add(mast);

  // Grupos para flechas y discos
  const arrowsGroup = new THREE.Group();
  const disksGroup  = new THREE.Group();
  buoyGroup.add(arrowsGroup);
  buoyGroup.add(disksGroup);

  // Posici√≥n de la boya en escena
  buoyGroup.position.y = -3;
  scene.add(buoyGroup);

  // Contenedor HUD (rosa y otros overlays)
  const indicatorsContainer = document.createElement('div');
  indicatorsContainer.style.position = 'absolute';
  indicatorsContainer.style.top = '0';
  indicatorsContainer.style.left = '0';
  indicatorsContainer.style.width = '100%';
  indicatorsContainer.style.height = '100%';
  indicatorsContainer.style.pointerEvents = 'none';
  container.appendChild(indicatorsContainer);

  // === HUD 2D: Rosa de vientos ============================
  let roseHud, roseCanvas, roseCtx;

  function createRoseHud() {
    if (!roseHud) {
      roseHud = document.createElement('div');
      roseHud.id = 'roseHud';
      Object.assign(roseHud.style, {
        position: 'absolute',
        bottom: '12px',
        left: '12px',
        width: '160px',
        height: '160px',
        borderRadius: '12px',
        background: 'rgba(0, 29, 61, 0.65)',
        boxShadow: '0 6px 20px rgba(0,0,0,0.35) inset, 0 4px 10px rgba(0,0,0,0.25)',
        backdropFilter: 'blur(2px)',
        pointerEvents: 'none',
        overflow: 'hidden'
      });

      roseCanvas = document.createElement('canvas');
      roseCanvas.id = 'roseCanvas';
      roseCanvas.style.transformOrigin = '50% 50%';

      roseHud.appendChild(roseCanvas);
      container.appendChild(roseHud);
const freezeContainer = document.createElement('div');
Object.assign(freezeContainer.style, {
  position: 'absolute',
  bottom: '12px',
  left: 'calc(12px + 160px + 8px)',
  height: '160px',
  display: 'flex',
  alignItems: 'flex-end',
  pointerEvents: 'auto',
  zIndex: '40'
});

// Wrapper interno para alineaci√≥n m√°s precisa
const freezeWrapper = document.createElement('div');
Object.assign(freezeWrapper.style, {
  display: 'flex',
  alignItems: 'center',
  background: 'rgba(255,255,255,0.05)',
  padding: '6px 10px',
  borderRadius: '8px',
  color: '#fff',
  fontSize: '14px',
  fontFamily: 'system-ui, sans-serif',
  backdropFilter: 'blur(6px)',
  boxShadow: '0 2px 6px rgba(0,0,0,0.25)'
});

const freezeCheckbox = document.createElement('input');
freezeCheckbox.type = 'checkbox';
freezeCheckbox.id = 'freezeCheckbox';
freezeCheckbox.style.margin = '0 6px 0 0';
freezeCheckbox.style.transform = 'scale(1.1)'; // Opcional: agranda un poco

const freezeLabel = document.createElement('label');
freezeLabel.htmlFor = 'freezeCheckbox';
freezeLabel.textContent = 'Centrar';
freezeLabel.style.lineHeight = '1';
freezeLabel.style.display = 'inline-block';







freezeCheckbox.addEventListener('change', () => {
  freezeBoya = freezeCheckbox.checked;

  if (freezeBoya) {
    buoyGroup.position.set(0, -3, 0);
    buoyGroup.rotation.set(0, 0, 0);
  }

  // üîÅ Vuelve a regenerar la escena de la boya seg√∫n el nuevo estado del checkbox
  actualizarBuoy();
});









freezeWrapper.appendChild(freezeCheckbox);
freezeWrapper.appendChild(freezeLabel);
freezeContainer.appendChild(freezeWrapper);
container.appendChild(freezeContainer);
      roseCtx = roseCanvas.getContext('2d');
      resizeRoseCanvas();
    }
  }

  function resizeRoseCanvas() {
    if (!roseHud) return;
    const dpr = window.devicePixelRatio || 1;
    const w = roseHud.clientWidth;
    const h = roseHud.clientHeight;
    roseCanvas.width = Math.max(1, Math.floor(w * dpr));
    roseCanvas.height = Math.max(1, Math.floor(h * dpr));
    roseCanvas.style.width = w + 'px';
    roseCanvas.style.height = h + 'px';
    roseCtx.setTransform(1,0,0,1,0,0);
    roseCtx.scale(dpr, dpr);
  }

  function drawRose(vectors) {
    createRoseHud();
    const W = roseHud.clientWidth, H = roseHud.clientHeight;
    const cx = W / 2, cy = H / 2;
    const R = Math.min(cx, cy) - 8;

    roseCtx.clearRect(0,0,W,H);

    for (let i = 5; i >= 1; i--) {
      const r = (R * i) / 5;
      roseCtx.beginPath();
      roseCtx.arc(cx, cy, r, 0, Math.PI * 2);
      roseCtx.fillStyle = `rgba(30, 90, 160, ${0.06 + (5 - i) * 0.05})`;
      roseCtx.fill();
    }

    roseCtx.strokeStyle = 'rgba(255,255,255,0.15)';
    roseCtx.lineWidth = 1;
    [['N', -90], ['E', 0], ['S', 90], ['O', 180]].forEach(([, ang]) => {
      const rad = ang * Math.PI / 180;
      roseCtx.beginPath();
      roseCtx.moveTo(cx, cy);
      roseCtx.lineTo(cx + R * Math.cos(rad), cy + R * Math.sin(rad));
      roseCtx.stroke();
    });
    roseCtx.font = 'bold 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    roseCtx.textAlign = 'center';
    roseCtx.textBaseline = 'middle';
    roseCtx.fillStyle = '#dfe9ff';
    // Correcci√≥n de letras cardinales: N arriba, S abajo, O derecha, E izquierda
roseCtx.fillText('S', cx, cy - R + 10); 
roseCtx.fillText('N', cx, cy + R - 10);
roseCtx.fillText('O', cx + R - 10, cy);  // Oeste a la derecha
roseCtx.fillText('E', cx - R + 10, cy);  // Este a la izquierda
    const MAG_TO_RADIUS = 0.9;
    function drawArrow(rad, mag, colorHex) {
      const color = '#' + colorHex.toString(16).padStart(6,'0');
      const len = (mag > 0 ? Math.min(R*0.9, Math.max(R*0.15, mag * R * MAG_TO_RADIUS)) : R*0.12);
      const x2 = cx + len * Math.cos(rad);
      const y2 = cy + len * Math.sin(rad);

      roseCtx.strokeStyle = color;
      roseCtx.lineWidth = 3;
      roseCtx.lineCap = 'round';
      roseCtx.beginPath();
      roseCtx.moveTo(cx, cy);
      roseCtx.lineTo(x2, y2);
      roseCtx.stroke();

      const head = Math.min(16, len * 0.25);
      const a = Math.atan2(y2 - cy, x2 - cx);
      const left = a + Math.PI - 0.5;
      const right = a + Math.PI + 0.5;
      roseCtx.beginPath();
      roseCtx.moveTo(x2, y2);
      roseCtx.lineTo(x2 + head * Math.cos(left),  y2 + head * Math.sin(left));
      roseCtx.lineTo(x2 + head * Math.cos(right), y2 + head * Math.sin(right));
      roseCtx.closePath();
      roseCtx.fillStyle = color;
      roseCtx.fill();

      roseCtx.beginPath();
      roseCtx.arc(cx, cy, 3, 0, Math.PI*2);
      roseCtx.fillStyle = 'rgba(255,255,255,0.8)';
      roseCtx.fill();
    }

    vectors.forEach(v => {
      const rad = (v.deg - 90) * Math.PI / 180;
      drawArrow(rad, v.magnitude ?? 0, v.colorHex ?? 0xff0000);
    });
  }

  function updateRoseFromArrowMeta() {
    const vecs = arrowMeta.map((m, i) => ({
      deg: m.azimuthDeg,
      magnitude: m.magnitude,
      colorHex: (i === 0) ? 0xff0000 : (i === 1 ? 0xffa500 : 0x00ff00)
    }));
    drawRose(vecs);
    updateRoseRotation();
  }

  // === HUD 2D: rotaci√≥n seg√∫n c√°mara ===
  function getCameraYawRad() {
    return Math.atan2(camera.position.x, camera.position.z);
  }
  function updateRoseRotation() {
    if (!roseCanvas) return;
    const yaw = getCameraYawRad();
 roseCanvas.style.transform = `rotate(${(yaw * 180 / Math.PI + 180)}deg)`;
  }

  // Globals
  window.lastRecord = null;
  window.profileLevels = null;
  let arrowMeta = [];

  // Helpers
  function getBinMagDir(bin) {
    if (!bin || typeof bin !== 'object') return { mag: 0, deg: 0 };
    const mag = Number(bin.Magnitude ?? bin.magnitude ?? 0);
    let deg   = Number(bin.Direction ?? bin.direction ?? 0);
    if (!isFinite(mag) || !isFinite(deg)) return { mag: 0, deg: 0 };
    deg = (deg % 360 + 360) % 360;
    return { mag, deg };
  }


  function degToDir3D(deg) {
  const rad = deg * Math.PI / 180;
  const x = Math.sin(rad);
  const z = -Math.cos(rad); // ‚Üê corregido: Z invertido
  return new THREE.Vector3(x, 0, z).normalize();
}


  function degToCompass8(deg) {
    const labels = ['N','NE','E','SE','S','SW','W','NW'];
    const idx = Math.round((deg % 360) / 45) % 8;
    return labels[idx];
  }

  // 3 niveles
  const levelsMeters = [5.0, 3.0, 1.0];
  const levelsTextMeters = [2.0, 10.0, 19.0];

  function pickProfileLevels(profileArr) {
    if (!Array.isArray(profileArr) || profileArr.length === 0) return null;
    const len = profileArr.length;
    const surface = profileArr[len - 1];
    const midIdx0 = Math.ceil(len / 2) - 1;
    const mid = profileArr[midIdx0];
    const deep = profileArr[0];
    return { first: surface, mid, fiftyThree: deep, indices: { first: len, mid: midIdx0 + 1, fiftyThree: 1 } };
  }

  // =========================
  //  ACTUALIZAR BOYA (flechas + tarjetas fijas)
  // =========================
  function actualizarBuoy() {
    try {
      //alert('üîß Iniciando actualizarBuoy()‚Ä¶');

      // Limpiar anteriores
      while (arrowsGroup.children.length) arrowsGroup.remove(arrowsGroup.children[0]);
      while (disksGroup.children.length)  disksGroup.remove(disksGroup.children[0]);
      const prevFixed = document.getElementById('fixedTagsContainer');
      if (prevFixed) prevFixed.remove();
      arrowMeta = [];

      const profile = window.profileLevels;
      if (!profile) {
        alert('‚ö†Ô∏è No hay profileLevels. ¬ølastRecord.Profile ven√≠a vac√≠o?');
        drawRose([]);
        return;
      }

      const pv = [
        { bin: profile.first,       idx: profile.indices?.first ?? 53, depthMeters: levelsMeters[0], color: 0xff0000 },
        { bin: profile.mid,         idx: profile.indices?.mid ?? 27,   depthMeters: levelsMeters[1], color: 0xffa500 },
        { bin: profile.fiftyThree,  idx: profile.indices?.fiftyThree ?? 1, depthMeters: levelsMeters[2], color: 0x00ff00 }
      ];

      //alert(`üìä Bins seleccionados -> #${pv[0].idx}, #${pv[1].idx}, #${pv[2].idx}`);

      pv.forEach((entry, i) => {
        const { mag, deg } = getBinMagDir(entry.bin);
        const depthMeters = entry.depthMeters;
        const depthTextMeters = levelsTextMeters[i];

       // alert(`‚û°Ô∏è Bin #${entry.idx}: Mag=${mag.toFixed(3)}, Dir=${deg.toFixed(0)}¬∞, Prof=${depthMeters} m`);

        const disk = new THREE.Mesh(
          new THREE.CircleGeometry(0.7, 64),
          new THREE.MeshBasicMaterial({ color: 0x007bff, opacity: 0.2, transparent: true, side: THREE.DoubleSide })
        );
        disk.rotation.x = -Math.PI / 2;
        disk.position.set(0, depthMeters, 0);
        disksGroup.add(disk);

        const dir3D = degToDir3D(deg);
        const gain = 15.0, minLen = 0.35, maxLen = 5.0;
        const length = Math.min(maxLen, Math.max(minLen, mag * gain));

        const origin = new THREE.Vector3(0, depthMeters, 0);
        const arrow = new THREE.ArrowHelper(dir3D, origin, length, entry.color, 0.3, 0.15);
        arrowsGroup.add(arrow);

        const compass = degToCompass8(deg);

        arrowMeta.push({
          originLocal: origin.clone(),
          dirLocal: dir3D.clone(),
          length,
          azimuthDeg: deg,
          compass,
          magnitude: mag,
          idx: entry.idx,
          depth: depthMeters,
          depthTextMeters
        });
      });












if (freezeBoya) {
  const ARC_Y_OFFSET = 3;

  // Reusar grupo si existe; si no, crearlo limpio
  let azimuthArcsGroup = scene.getObjectByName('azimuthArcsGroup');
  if (azimuthArcsGroup) {
    // si exist√≠a, lo limpiamos por si venimos de otro ciclo
    azimuthArcsGroup.traverse(obj => {
      if (obj.isLine) { obj.geometry.dispose(); obj.material.dispose(); }
      if (obj.isSprite) {
        if (obj.material.map) obj.material.map.dispose();
        obj.material.dispose();
      }
    });
    azimuthArcsGroup.clear();
  } else {
    azimuthArcsGroup = new THREE.Group();
    azimuthArcsGroup.name = 'azimuthArcsGroup';
    scene.add(azimuthArcsGroup);
  }

  arrowMeta.forEach((meta) => {
    const radius = 0.7;
    const segments = 32;
    const thetaStart = 0;
    const thetaEnd = THREE.MathUtils.degToRad(meta.azimuthDeg);
    const arcPoints = [];

    const steps = Math.ceil(segments * Math.abs(thetaEnd - thetaStart) / (2 * Math.PI));

    for (let i = 0; i <= steps; i++) {
      const theta = thetaStart + (i / steps) * (thetaEnd - thetaStart);
      arcPoints.push(new THREE.Vector3(
        radius * Math.sin(theta),
        meta.depth - ARC_Y_OFFSET,
        -radius * Math.cos(theta)
      ));
    }

    const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
    const arcMaterial = new THREE.LineDashedMaterial({
      color: 0xffffff,
      linewidth: 1,
      dashSize: 0.1,
      gapSize: 0.05,
      scale: 1
    });

    const arcLine = new THREE.Line(arcGeometry, arcMaterial);
    arcLine.computeLineDistances();
    azimuthArcsGroup.add(arcLine); // <-- agrupar arco

    const midDeg = meta.azimuthDeg / 2;
    const midRad = THREE.MathUtils.degToRad(midDeg);
    const extendedRadius = radius + 0.25;

    const labelPos = new THREE.Vector3(
      extendedRadius * Math.sin(midRad),
      meta.depth - ARC_Y_OFFSET + 0.05,
      -extendedRadius * Math.cos(midRad)
    );

    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 512;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.font = 'bold 80px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const text = `${meta.azimuthDeg.toFixed(0)}¬∞`;
    ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(1.5, 0.75, 1);
    sprite.position.copy(labelPos);

    azimuthArcsGroup.add(sprite); // <-- agrupar etiqueta tambi√©n
  });

  // Asegurar en escena (si no estaba)
  if (!scene.children.includes(azimuthArcsGroup)) {
    scene.add(azimuthArcsGroup);
  }

  scene.add(dashedLinesGroup);

} else {
  // Eliminar dashedLinesGroup
  if (scene.children.includes(dashedLinesGroup)) {
    scene.remove(dashedLinesGroup);
  }

  // Eliminar grupo de arcos y liberar recursos
  const azimuthArcsGroup = scene.getObjectByName('azimuthArcsGroup');
  if (azimuthArcsGroup) {
    azimuthArcsGroup.traverse(obj => {
      if (obj.isLine) { obj.geometry.dispose(); obj.material.dispose(); }
      if (obj.isSprite) {
        if (obj.material.map) obj.material.map.dispose();
        obj.material.dispose();
      }
    });
    scene.remove(azimuthArcsGroup);
    azimuthArcsGroup.clear();
  }
}





























      // === Tarjetas tipo counter: columna fija a la derecha ===
      const fixedTagsContainer = document.createElement('div');
      fixedTagsContainer.id = 'fixedTagsContainer';
      Object.assign(fixedTagsContainer.style, {
        position: 'absolute',
        top: '50%',
transform: 'translateY(-50%)',           // ajusta seg√∫n tu header/counters
        right: '16px',
        display: 'flex',
        flexDirection: 'column',
        gap: '12px',
        zIndex: '30',
        pointerEvents: 'none'   // evita capturar mouse sobre la escena
      });
      container.appendChild(fixedTagsContainer);

   arrowMeta.forEach((meta, i) => {
  const card = document.createElement('div');

  // Fondo transl√∫cido con color distintivo
  const backgroundGradient = i === 0
    ? 'linear-gradient(to bottom right, rgba(255,0,0,0.6), rgba(255,0,0,0.2))'
    : i === 1
      ? 'linear-gradient(to bottom right, rgba(255,165,0,0.6), rgba(255,165,0,0.2))'
      : 'linear-gradient(to bottom right, rgba(0,255,0,0.6), rgba(0,255,0,0.2))';
//
  Object.assign(card.style, {
    padding: '10px 16px',
    backgroundImage: backgroundGradient,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    border: '1px solid rgba(255, 255, 255, 0.2)',
    borderRadius: '12px',
    backdropFilter: 'blur(8px)',
    WebkitBackdropFilter: 'blur(8px)',
    color: '#fff',
    fontSize: '13px',
    fontWeight: '500',
    fontFamily: 'system-ui, sans-serif',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.3)',
    whiteSpace: 'nowrap',
    textAlign: 'left',
    lineHeight: '1.5',
    maxWidth: '220px',
    pointerEvents: 'auto'
  });

card.innerHTML = `
  üìç <strong>Bin #${meta.idx}</strong>: ${meta.depthTextMeters} m<br>
  Dir: ${meta.azimuthDeg.toFixed(0)}¬∞ (${meta.compass})<br>
  Mag: ${(meta.magnitude * 2).toFixed(3)} (kn)
`;

  fixedTagsContainer.appendChild(card);
});


      // üëâ Actualiza la rosa 2D con los 3 vectores
      updateRoseFromArrowMeta();
// Elimina l√≠neas anteriores si existen
while (dashedLinesGroup.children.length) {
  dashedLinesGroup.remove(dashedLinesGroup.children[0]);
}

// Crea l√≠nea blanca punteada hacia el norte para cada profundidad
arrowMeta.forEach(meta => {
  const line = createDashedLineAtY(meta.depth);
  dashedLinesGroup.add(line);
});


// üëá Aqu√≠ va la l√≠nea que las baja
dashedLinesGroup.position.y = -3.0;
      //alert('‚úÖ actualizarBuoy() completado');
    } catch (e) {
      console.error(e);
      alert('‚ùå Error en actualizarBuoy(): ' + e.message);
    }
  }

  // Animaci√≥n escena
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);

    const radius = 10;
    camera.position.x = radius * Math.sin(targetRotationX) * Math.cos(targetRotationY);
    camera.position.y = radius * Math.sin(targetRotationY);
    camera.position.z = radius * Math.cos(targetRotationX) * Math.cos(targetRotationY);
    camera.lookAt(0, 0, 0);

    const pos = bubblesGeometry.attributes.position.array;
    for (let i = 0; i < bubbleCount; i++) {
      pos[i * 3 + 1] += 0.002 + Math.random() * 0.0015;
      if (pos[i * 3 + 1] > 3) pos[i * 3 + 1] = -3;
    }
    bubblesGeometry.attributes.position.needsUpdate = true;

    const time = clock.getElapsedTime();
    const vertices = waterGeometry.attributes.position;
    for (let i = 0; i < vertices.count; i++) {
      const x = vertices.getX(i);
      const wave = 0.1 * Math.sin(x * 3 + time * 3);
      vertices.setZ(i, wave);
    }
    vertices.needsUpdate = true;
    waterGeometry.computeVertexNormals();
if (!freezeBoya) {
  buoyGroup.rotation.x = 0.05 * Math.sin(time * 2);
  buoyGroup.rotation.y = 0;
} else {
  buoyGroup.rotation.set(0, 0, 0); // Por si acaso lo reafirmamos
  buoyGroup.position.set(0, -3, 0); // Reafirma su posici√≥n exacta
}

    updateRoseRotation();
    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h);
    resizeRoseCanvas();
    updateRoseFromArrowMeta();
    updateRoseRotation();
  });

  // Interacci√≥n mouse
  container.addEventListener('mousedown', (e) => { isMouseDown = true; mouseX = e.clientX; mouseY = e.clientY; });
  window.addEventListener('mouseup', () => { isMouseDown = false; });
  window.addEventListener('mousemove', (e) => {
    if (isMouseDown) {
      const dx = e.clientX - mouseX; const dy = e.clientY - mouseY;
      mouseX = e.clientX; mouseY = e.clientY;
      targetRotationX += dx * 0.005; targetRotationY += dy * 0.005;
      targetRotationY = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationY));
    }
  });


// üåç Variables globales para el √∫ltimo registro
let lastHs = null;
let lastTp = null;
let lastDir = null;
let lastDep = null;



  // =========================
  //  TABLA + CARGA DE REGISTROS
  // =========================
  let registros = [];
  let currentPage = 1;
  const rowsPerPage = 10;

  async function cargarRegistros() {
    console.log('üì¶ Iniciando carga de registros...');
    alert('üì¶ Iniciando carga de registros...');

    try {
      const response = await fetch('/registros');
      console.log('‚úÖ Respuesta recibida del backend');
     // alert('‚úÖ Respuesta recibida');

      const data = await response.json();
      console.log(`üî¢ Total de registros recibidos: ${data.length}`);
      alert(`üî¢ Total de registros recibidos: ${data.length}`);

      window.lastRecord = (Array.isArray(data) && data.length) ? data[data.length - 1] : null;

if (window.lastRecord) {
  // Guarda valores globales
  lastHs  = window.lastRecord.Hs ?? null;
  lastTp  = window.lastRecord.Tp ?? null;
  lastDir = window.lastRecord.Dp ?? window.lastRecord.Dmean ?? null;
  lastDep = window.lastRecord.Depth ?? null;

  console.log("üåä Hs (m):", lastHs);
  console.log("‚è±Ô∏è Tp (s):", lastTp);
  console.log("üß≠ Dir (¬∞):", lastDir);
  console.log("üìè Dep (m):", lastDep);

  // ‚úÖ Actualizar tarjetas
  document.getElementById("hsValue").textContent  = lastHs  ?? "--";
  document.getElementById("tpValue").textContent  = lastTp  ?? "--";
  document.getElementById("dirValue").textContent = lastDir ?? "--";
  document.getElementById("depValue").textContent = lastDep != null ? ((lastDep / 1000) - 19).toFixed(2) : "--";
}
      if (window.lastRecord?.Profile) {
        window.profileLevels = pickProfileLevels(window.lastRecord.Profile);

        console.log('üëâ √öltimo n_registro:', window.lastRecord?.n_registro);
        console.log('üëâ Profile superficie (#' + window.profileLevels?.indices?.first + '):', window.profileLevels?.first);
        console.log('üëâ Profile mitad (#' + window.profileLevels?.indices?.mid + '):', window.profileLevels?.mid);
        console.log('üëâ Profile fondo (#' + window.profileLevels?.indices?.fiftyThree + '):', window.profileLevels?.fiftyThree);

        actualizarBuoy();
      } else {
        window.profileLevels = null;
        console.warn('‚ö†Ô∏è El √∫ltimo registro no contiene Profile v√°lido.');
        alert('‚ö†Ô∏è El √∫ltimo registro no contiene Profile v√°lido.');
        drawRose([]);
      }

      registros = data.slice(-780).reverse();
      currentPage = 1;
      mostrarPagina(currentPage);
      actualizarBotonesPaginacion();
      console.log('‚úÖ Registros cargados en la tabla');
      //alert('‚úÖ Registros cargados en la tabla');

      const ultimosRegistros = registros.slice(0, 144).reverse();
      const labels = ultimosRegistros.map(r => {
        const ts = r.Timestamp;
        return `${String(ts.Hour).padStart(2, '0')}:${String(ts.Minute).padStart(2, '0')}`;
      });

      const dataHs = ultimosRegistros.map(r => r.Hs ?? 0);
      const dataTp = ultimosRegistros.map(r => r.Tp ?? 0);
      const dataDepth = ultimosRegistros.map(r => {
        const raw = r.Depth;
        return (typeof raw === 'number') ? (raw / 1000) - 20 : 0;
      });

      actualizarGraficos(labels, dataHs, dataTp, dataDepth);

    } catch (error) {
      console.error('‚ùå Error al cargar los registros:', error);
      alert('‚ùå Error al cargar los registros: ' + error.message);
      drawRose([]);
    }
  }

  function mostrarPagina(page) {
    const tbody = document.querySelector('#tabla-registros tbody');
    if (!tbody) {
      console.error('‚ùå No se encontr√≥ la tabla en el DOM');
      alert('‚ùå No se encontr√≥ la tabla en el DOM');
      return;
    }
    tbody.innerHTML = '';

    const start = (page - 1) * rowsPerPage;
    const end = start + rowsPerPage;
    const pageItems = registros.slice(start, end);

    pageItems.forEach((registro, i) => {
      const ts = registro.Timestamp;
      const fecha = `${ts.Day}-${ts.Month}-${ts.Year}`;
      const hora = `${ts.Hour}:${ts.Minute}`;
      const hs = registro.Hs ?? '‚Äì';
      const tp = registro.Tp ?? '‚Äì';
      const dp = registro.Dp ?? '‚Äì';
      const depthRaw = registro.Depth;
      const depth = (typeof depthRaw === 'number') ? ((depthRaw / 1000) - 19).toFixed(2) : '‚Äì';
      const nRegistro = registro.n_registro ?? '‚Äì';

      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${nRegistro}</td>
        <td>${fecha}</td>
        <td>${hora}</td>
        <td>${hs}</td>
        <td>${tp}</td>
        <td>${dp}</td>
        <td>${depth}</td>
      `;
      tbody.appendChild(row);
    });

    document.getElementById('pageInfo').textContent = `P√°gina ${page} de ${Math.ceil(registros.length / rowsPerPage)}`;
  }

  function actualizarBotonesPaginacion() {
    const totalPages = Math.ceil(registros.length / rowsPerPage);
    document.getElementById('prevPage').disabled = currentPage <= 1;
    document.getElementById('nextPage').disabled = currentPage >= totalPages;
  }

  document.getElementById('prevPage').addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--; mostrarPagina(currentPage); actualizarBotonesPaginacion();
    }
  });
  document.getElementById('nextPage').addEventListener('click', () => {
    const totalPages = Math.ceil(registros.length / rowsPerPage);
    if (currentPage < totalPages) {
      currentPage++; mostrarPagina(currentPage); actualizarBotonesPaginacion();
    }
  });

  // Init
  document.addEventListener('DOMContentLoaded', () => {
    console.log('üìÑ DOM completamente cargado');
    initCharts();


    cargarRegistros();
  });
</script>
