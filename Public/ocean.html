<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fondo Marino + Sistema ADCP en el fondo</title>
  <style>
    body, html {
      margin: 0; 
      padding: 0; 
      height: 100%;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #001D3D;
      font-family: Arial, sans-serif;
      overflow: hidden;
      position: relative;
    }
    #container {
      width: 600px;
      height: 600px;
      border-radius: 12px;
      box-shadow: 0 0 15px #004080aa;
      background-color: #001D3D;
      position: relative;
      overflow: visible;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 12px;
    }

    /* Contenedor para los pop-ups */
    #popups-container {
      position: absolute;
      top: 0; left: 0; 
      width: 100%;
      height: 100%;
      pointer-events: none; /* No bloquean interacción del canvas */
      z-index: 10;
    }

    /* Estilo para los pop-ups */
    .popup {
      position: absolute;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.25);
      font-size: 14px;
      color: #001D3D;
      max-width: 140px;
      pointer-events: auto; /* Permite interacción si se quiere */
      user-select: none;
      font-weight: bold;
    }
  </style>
</head>
<body>

  <div id="container">

  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    const container = document.getElementById('container');
    const scene = new THREE.Scene();

    // Cámara
    const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 3, 10);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // Luz ambiental y direccional
    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0x70aaff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // Fondo oceánico
    const oceanFloorGeometry = new THREE.PlaneGeometry(7, 7, 4, 4);
    const oceanFloorMaterial = new THREE.MeshPhongMaterial({
      color: 0x003050,
      side: THREE.DoubleSide,
      shininess: 10,
    });
    const oceanFloor = new THREE.Mesh(oceanFloorGeometry, oceanFloorMaterial);
    oceanFloor.rotation.x = -Math.PI / 2;
    oceanFloor.position.y = -3;
    scene.add(oceanFloor);

    // Agua (superficie con olas)
    const waterGeometry = new THREE.PlaneGeometry(6, 6, 20, 20);
    const waterMaterial = new THREE.MeshPhongMaterial({
      color: 0x1E90FF,
      transparent: true,
      opacity: 0.6,
      side: THREE.DoubleSide,
      shininess: 100,
      flatShading: true
    });
    const water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.rotation.x = -Math.PI / 2;
    water.position.y = 3;
    scene.add(water);

    // Burbujas
    const bubbleCount = 50;
    const bubblesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(bubbleCount * 3);
    for(let i = 0; i < bubbleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 6;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 6;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 6;
    }
    bubblesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const bubblesMaterial = new THREE.PointsMaterial({
      color: 0xA0C8FF,
      size: 0.05,
      transparent: true,
      opacity: 0.3,
      depthWrite: false,
    });
    const bubbles = new THREE.Points(bubblesGeometry, bubblesMaterial);
    scene.add(bubbles);

    // === SISTEMA ADCP (boya) en el fondo ===
    const buoyGroup = new THREE.Group();

    // Cuerpo esfera roja
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 32, 32),
      new THREE.MeshPhongMaterial({ color: 0xff4444 })
    );
    sphere.position.y = 0.5;
    buoyGroup.add(sphere);

    // Mástil amarillo extendido casi hasta las olas
    const mast = new THREE.Mesh(
      new THREE.CylinderGeometry(0.05, 0.05, 5.7, 16),
      new THREE.MeshPhongMaterial({ color: 0xffff00 })
    );
    mast.position.y = 2.85;
    buoyGroup.add(mast);

    // Discos y flechas
    const levels2 = [5.0, 3, 1];
    const directions = [
      new THREE.Vector2(1, 0.5),
      new THREE.Vector2(0.8, -0.7),
      new THREE.Vector2(-1.2, 0.3)
    ];

    const colors2 = [0xff0000, 0xffa500, 0x00ff00];

    levels2.forEach((y, i) => {
      const disk = new THREE.Mesh(
        new THREE.CircleGeometry(0.7, 64),
        new THREE.MeshBasicMaterial({ color: 0x007bff, opacity: 0.2, transparent: true, side: THREE.DoubleSide })
      );
      disk.rotation.x = -Math.PI / 2;
      disk.position.set(0, y, 0);
      buoyGroup.add(disk);

      const dir2D = directions[i].normalize();
      const dir3D = new THREE.Vector3(dir2D.x, 0, dir2D.y);
      const origin = new THREE.Vector3(0, y, 0);
      const arrow = new THREE.ArrowHelper(dir3D, origin, 1, colors2[i], 0.2, 0.1);
      buoyGroup.add(arrow);
    });

    // Posición en el fondo
    buoyGroup.position.y = -3;
    scene.add(buoyGroup);

    // --- Indicadores numéricos para las flechas ---
    const indicatorsContainer = document.createElement('div');
    indicatorsContainer.style.position = 'absolute';
    indicatorsContainer.style.top = '0';
    indicatorsContainer.style.left = '0';
    indicatorsContainer.style.width = '100%';
    indicatorsContainer.style.height = '100%';
    indicatorsContainer.style.pointerEvents = 'none';
    container.appendChild(indicatorsContainer);

    const indicators = [];
    colors2.forEach((color, i) => {
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.padding = '4px 8px';
      div.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
      div.style.color = '#fff';
      div.style.fontSize = '12px';
      div.style.borderRadius = '4px';
      div.style.whiteSpace = 'nowrap';
      div.style.transform = 'translate(-50%, -100%)';
      div.innerText = `Nivel ${levels2[i]} m`;
      indicatorsContainer.appendChild(div);
      indicators.push(div);
    });

    function updateIndicators() {
      levels2.forEach((y, i) => {
        const pos3D = new THREE.Vector3(0, y, 0);
        buoyGroup.localToWorld(pos3D);
        const vector = pos3D.project(camera);

        const x = (vector.x * 0.5 + 0.8) * container.clientWidth;
        const y2 = (-vector.y * 0.5 + 0.5) * container.clientHeight;

        indicators[i].style.left = `${x}px`;
        indicators[i].style.top = `${y2}px`;
      });
    }

    // --- NUEVOS 4 CUADROS ARRIBA DE LAS OLAS ---
    const topBoxesContainer = document.createElement('div');
    topBoxesContainer.style.position = 'absolute';
    topBoxesContainer.style.top = '10px';
    topBoxesContainer.style.left = '50%';
    topBoxesContainer.style.transform = 'translateX(-50%)';
    topBoxesContainer.style.display = 'flex';
    topBoxesContainer.style.gap = '12px';
    topBoxesContainer.style.pointerEvents = 'auto';
    container.appendChild(topBoxesContainer);

    const topBoxes = [];
    for(let i = 1; i <= 4; i++) {
      const box = document.createElement('div');
      box.style.backgroundColor = '#007bff';
      box.style.color = 'white';
      box.style.padding = '10px 16px';
      box.style.borderRadius = '12px';
      box.style.fontWeight = 'bold';
      box.style.fontSize = '14px';
      box.style.userSelect = 'none';
      box.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
      box.innerText = `Hs (m)`;
      topBoxesContainer.appendChild(box);
      topBoxes.push(box);
    }

    // Animación y movimiento de olas + boya
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      // Animar burbujas subiendo
      const pos = bubblesGeometry.attributes.position.array;
      for(let i = 0; i < bubbleCount; i++) {
        pos[i * 3 + 1] += 0.002 + Math.random() * 0.0015;
        if (pos[i * 3 + 1] > 3) pos[i * 3 + 1] = -3;
      }
      bubblesGeometry.attributes.position.needsUpdate = true;

      // Animar olas
      const time = clock.getElapsedTime();
      const vertices = waterGeometry.attributes.position;
      for(let i = 0; i < vertices.count; i++) {
        const x = vertices.getX(i);
        const wave = 0.3 * Math.sin(x * 3 + time * 3);
        vertices.setZ(i, wave);
      }
      vertices.needsUpdate = true;
      waterGeometry.computeVertexNormals();

      // Animar boya: rotación lenta sin movimiento vertical
      buoyGroup.rotation.y += 0.01;
      buoyGroup.rotation.x = 0.05 * Math.sin(time * 2);

      // Actualizar posición de indicadores
      updateIndicators();

      renderer.render(scene, camera);
    }
    animate();

    // Adaptar a resize del contenedor
    window.addEventListener('resize', () => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  </script>
</body>
</html>


